/**
 * Знает алгоритмы, и разницу между ними.
 * Sorting algorithms: bubble, selection, insertion, merge, radixsort
 */

// ------------------------------------------------------------

/**
 * Bubble Sort (Пузырьковая сортировка)
 * Суть: Много раз проходим по массиву, попарно меняем соседние элементы,
 * если они не в порядке, и «тяжёлые» элементы «всплывают» к концу массива.
 *
 * Плюсы:
 * - Очень простая реализация
 * - Хорош для учебных целей
 *
 * Минусы:
 * - Очень медленный для больших массивов (O(n²))
 *
 * Где используется:
 * Для небольших или почти отсортированных массивов.
 */

function bubbleSort(initialArray: Array<number>): Array<number> {
  const array = [...initialArray]; // копируем массив, чтобы избежать мутации

  for (let i = 0; i < array.length - 1; i++) {
    for (let j = 0; j < array.length - 1 - i; j++) {
      // если текущий элемент больше следующего - меняем местами
      if (array[j] > array[j + 1]) {
        [array[j], array[j + 1]] = [array[j + 1], array[j]];
      }
    }
  }

  return array;
}

// ------------------------------------------------------------

/**
 * Selection Sort (Сортировка выбором)
 * Суть: Для каждого места находим минимальный элемент из оставшихся и ставим на своё место.
 *
 * Плюсы:
 * - Просто понять и реализовать
 * - Делает минимум перестановок
 *
 * Минусы:
 * - Всё равно O(n²); для больших массивов не годится
 *
 * Где используется:
 * Для очень коротких массивов.
 */

function selectionSort(initialArray: Array<number>): Array<number> {
  const array = [...initialArray]; // копируем массив, чтобы избежать мутации

  for (let i = 0; i < array.length - 1; i++) {
    let minIdx = i; // индекс минимального элемента

    for (let j = i + 1; j < array.length; j++) {
      // если текущий элемент меньше минимального - обновляем индекс
      if (array[j] < array[minIdx]) {
        minIdx = j;
      }
    }

    [array[i], array[minIdx]] = [array[minIdx], array[i]]; // меняем местами
  }

  return array;
}

// ------------------------------------------------------------

/**
 * Insertion Sort (Сортировка вставками)
 * Суть: Постепенно «строит» отсортированную часть массива, вставляя в неё новые элементы.
 *
 * Плюсы:
 * - Очень быстро сработает на почти отсортированных массивах
 * - Простая реализация
 *
 * Минусы:
 * - O(n²) в худшем случае, если данные наоборот отсортированы
 *
 * Где используется:
 * Для небольших или почти отсортированных массивов.
 */

function insertionSort(initialArray: Array<number>): Array<number> {
  const array = [...initialArray]; // копируем массив, чтобы избежать мутации

  for (let i = 1; i < array.length; i++) {
    let key = array[i]; // текущий элемент
    let j = i - 1; // индекс предыдущего элемента
    // если текущий элемент меньше предыдущего - сдвигаем элементы вправо
    while (j >= 0 && array[j] > key) {
      array[j + 1] = array[j];
      j--;
    }
    array[j + 1] = key; // вставляем текущий элемент на правильное место
  }

  return array;
}

// ------------------------------------------------------------

/**
 * Merge Sort (Сортировка слиянием)
 * Суть: Рекурсивно делим массив пополам (пока остаются одиночные элементы), сортируем каждую часть отдельно, потом сливаем в один отсортированный.
 *
 * Плюсы:
 * - Быстро для больших объёмов (O(n log n) всегда)
 * - Стабильная сортировка (не меняет порядок одинаковых элементов)
 *
 * Минусы:
 * - Требует дополнительной памяти (копии массивов при объединении)
 *
 * Где используется:
 * Подходит для сортировки больших коллекций (особенно если нужен стабильный результат — например, список заказов по дате).
 */

function mergeSort(initialArray: Array<number>): Array<number> {
  const array = [...initialArray]; // копируем массив, чтобы избежать мутации

  if (array.length < 2) {
    return array;
  }

  const mid = Math.floor(array.length / 2); // находим середину массива
  const left = mergeSort(array.slice(0, mid)); // сортируем левую часть
  const right = mergeSort(array.slice(mid)); // сортируем правую часть
  const merged: Array<number> = [];

  let li = 0; // индекс левой части
  let ri = 0; // индекс правой части

  while (li < left.length && ri < right.length) {
    merged.push(left[li] < right[ri] ? left[li++] : right[ri++]); // добавляем меньший элемент в результат
  }

  return merged.concat(left.slice(li), right.slice(ri)); // добавляем оставшиеся элементы
}

// ------------------------------------------------------------

/**
 * Radix Sort
 * Суть: Не сравнивает элементы, а сортирует по разрядам (числам или буквам) — по «корзинам».
 *
 * Плюсы:
 * - Для целых чисел/строк — может работать очень быстро (O(n*k), где k — разрядность)
 * - Нет "сравнения", сортировка по buckets
 *
 * Минусы:
 * - Только для специальных случаев (целые числа, строки одинаковой длины и т.п.)
 * - Используется редко "вручную", часто реализован в библиотеках
 *
 * Где используется:
 * Очень большие массивы чисел с одинаковой разрядностью (например, сортировка телефонных номеров, больших логов по сжатию время-меток).
 * Почти не применяется вручную на фронте, зато может быть в "потоковых" задачах.
 */

function radixSort(initialArray: Array<number>): Array<number> {
  const max = Math.max(...initialArray); // находим максимальное число
  let exp = 1; // начальная степень 10
  let array = [...initialArray]; // копируем массив, чтобы избежать мутации

  // пока степень 10 меньше максимального числа
  while (Math.floor(max / exp) > 0) {
    const buckets: Array<Array<number>> = Array.from({ length: 10 }, () => []); // создаем 10 корзин
    for (const num of array) {
      buckets[Math.floor(num / exp) % 10].push(num); // добавляем число в соответствующую корзину
    }
    array = ([] as Array<number>).concat(...buckets); // объединяем корзины
    exp *= 10; // увеличиваем степень 10
  }

  return array;
}
